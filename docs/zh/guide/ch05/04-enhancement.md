---
title: 5.4 å›¾åƒå¢žå¼ºä¸Žæ¢å¤
description: åŒ»å­¦å›¾åƒå¢žå¼ºä¸Žæ¢å¤æŠ€æœ¯
---

# 5.4 å›¾åƒå¢žå¼ºä¸Žæ¢å¤

> "æ•°æ®å¢žå¼ºæ˜¯åŒ»å­¦å½±åƒæ·±åº¦å­¦ä¹ çš„'è´«ç©·è€…çš„åˆ©å™¨'ï¼Œè€Œå›¾åƒæ¢å¤åˆ™æ˜¯'æ—¶é—´æœºå™¨'ï¼Œèƒ½å¤Ÿé‡å»ºä¸¢å¤±çš„ä¿¡æ¯ã€‚" â€” åŒ»å­¦å½±åƒç ”ç©¶ä¸­çš„ç»å…¸æ¯”å–»

åœ¨å‰é¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†é¢„å¤„ç†ã€åˆ†å‰²ã€åˆ†ç±»å’Œæ£€æµ‹çš„æ ¸å¿ƒæŠ€æœ¯ã€‚çŽ°åœ¨ï¼Œæˆ‘ä»¬å°†æŽ¢è®¨ä¸¤ä¸ªå…³é”®çš„ä¸»é¢˜ï¼š**å›¾åƒå¢žå¼º**å’Œ**å›¾åƒæ¢å¤**ã€‚è¿™ä¸¤ä¸ªæŠ€æœ¯è™½ç„¶ç›®æ ‡ä¸åŒï¼Œä½†éƒ½è‡´åŠ›äºŽæå‡åŒ»å­¦å›¾åƒçš„è´¨é‡å’Œä¿¡æ¯é‡ã€‚

åŒ»å­¦å½±åƒé¢†åŸŸé¢ä¸´ç€ç‹¬ç‰¹çš„æŒ‘æˆ˜ï¼šæ•°æ®ç¨€ç¼ºæ€§ã€é‡‡é›†æ¡ä»¶çš„å·®å¼‚ã€å™ªå£°å¹²æ‰°ã€ä»¥åŠä¸å¯é¿å…çš„å›¾åƒè´¨é‡ä¸‹é™ã€‚å›¾åƒå¢žå¼ºé€šè¿‡ç”Ÿæˆæ›´å¤šæ ·åŒ–çš„è®­ç»ƒæ•°æ®æ¥æå‡æ¨¡åž‹æ³›åŒ–èƒ½åŠ›ï¼Œè€Œå›¾åƒæ¢å¤åˆ™è‡´åŠ›äºŽä¿®å¤é€€åŒ–çš„å›¾åƒè´¨é‡ã€‚è®©æˆ‘ä»¬æ·±å…¥æŽ¢ç´¢è¿™ä¸¤ä¸ªé‡è¦é¢†åŸŸã€‚

---

## ðŸŽ¨ åŒ»å­¦å›¾åƒå¢žå¼ºåŸºç¡€æŠ€æœ¯

### ðŸ“‹ åŒ»å­¦å›¾åƒå¢žå¼ºçš„ç‹¬ç‰¹æŒ‘æˆ˜

**åŒ»å­¦å›¾åƒå¢žå¼ºè¿œæ¯”è‡ªç„¶å›¾åƒå¤æ‚ï¼Œéœ€è¦åŒæ—¶è€ƒè™‘æŠ€æœ¯å¯è¡Œæ€§å’ŒåŒ»å­¦åˆç†æ€§**ï¼š

#### ðŸ§  å¢žå¼ºçš„åŒ»å­¦çº¦æŸæ¡ä»¶

**1. è§£å‰–å­¦å®Œæ•´æ€§çº¦æŸï¼š**
- **ç»“æž„ä¿æŒ**ï¼šå¿ƒã€è‚ã€è‚ºç­‰å™¨å®˜çš„ç›¸å¯¹ä½ç½®ä¸èƒ½éšæ„æ”¹å˜
- **å¯¹ç§°æ€§ç»´æŠ¤**ï¼šäººä½“å·¦å³å¯¹ç§°ç»“æž„éœ€è¦ç‰¹åˆ«å¤„ç†
- **è¿žç»­æ€§è¦æ±‚**ï¼šè¡€ç®¡ã€ç¥žç»çš„è¿žç»­æ€§ä¸èƒ½è¢«ç ´å

**2. ç—…ç†å­¦çœŸå®žæ€§çº¦æŸï¼š**
- **ç—…ç¶ç‰¹å¾ä¿æŒ**ï¼šè‚¿ç˜¤ã€ç‚Žç—‡ç­‰ç—…ç†ç‰¹å¾å¿…é¡»ä¿ç•™
- **è¾¹ç•Œæ¸…æ™°åº¦**ï¼šç—…ç¶è¾¹ç•Œçš„ä¸´åºŠæ„ä¹‰ä¸èƒ½æ¨¡ç³ŠåŒ–
- **å¯¹æ¯”åº¦ç»´æŒ**ï¼šæ­£å¸¸ç»„ç»‡ä¸Žå¼‚å¸¸ç»„ç»‡çš„å¯¹æ¯”åº¦éœ€è¦ä¿æŒ

**3. ä¸´åºŠé€‚ç”¨æ€§çº¦æŸï¼š**
- **å¯è§£é‡Šæ€§**ï¼šå¢žå¼ºåŽçš„å›¾åƒåŒ»ç”Ÿä»èƒ½ç†è§£
- **è¯Šæ–­ä¸€è‡´æ€§**ï¼šä¸èƒ½äº§ç”Ÿè¯¯å¯¼æ€§çš„è¯Šæ–­ä¿¡æ¯
- **åˆè§„æ€§**ï¼šç¬¦åˆåŒ»å­¦å½±åƒçš„æŠ€æœ¯æ ‡å‡†å’Œè§„èŒƒ

#### ðŸ”§ ä¸åŒæ¨¡æ€çš„ä¸“é—¨å¢žå¼ºç­–ç•¥

| æ¨¡æ€ | ä¸»è¦æŒ‘æˆ˜ | æŽ¨èå¢žå¼ºæ–¹æ³• | é¿å…æ“ä½œ |
|------|---------|-------------|----------|
| **CT** | HUå€¼èŒƒå›´å›ºå®šã€é‡‘å±žä¼ªå½± | å¼¹æ€§å˜å½¢ã€å¼ºåº¦æ‰°åŠ¨ | æ—‹è½¬>10Â°ã€æžç«¯å¯¹æ¯”åº¦ |
| **MRI** | å¤šåºåˆ—ã€ååœºåœº | åºåˆ—èžåˆã€ååœºæ¨¡æ‹Ÿ | ç ´ååºåˆ—ä¸€è‡´æ€§ |
| **Xå…‰** | æŠ•å½±é‡å ã€2Dç‰¹å¾ | æŠ•å½±å‡ ä½•å˜æ¢ã€å™ªå£°æ·»åŠ  | 3Dæ—‹è½¬ã€è‰²å½©å˜æ¢ |
| **è¶…å£°** | å™ªå£°å¤šã€ä¾èµ–è§’åº¦ | è§’åº¦å˜æ¢ã€æ•£æ–‘å™ªå£° | ç ´åæ‰«æå‡ ä½•å…³ç³» |

#### ðŸŽ¯ å¢žå¼ºæ•ˆæžœçš„è¯„ä¼°æ ‡å‡†

**å®¢è§‚è¯„ä¼°æŒ‡æ ‡ï¼š**
- **å›¾åƒè´¨é‡**ï¼šSNRã€CNRã€ç†µå€¼
- **è§£å‰–å®Œæ•´æ€§**ï¼šå™¨å®˜ä½“ç§¯ã€å½¢çŠ¶ç›¸ä¼¼åº¦
- **ç—…ç†ä¿æŒåº¦**ï¼šç—…ç¶ç‰¹å¾ç›¸ä¼¼ç³»æ•°

**ä¸»è§‚è¯„ä¼°æ–¹æ³•ï¼š**
- **åŒ»ç”Ÿè¯„ä»·**ï¼šè¯Šæ–­ä»·å€¼ä¿æŒç¨‹åº¦
- **ä¸´åºŠé€‚ç”¨æ€§**ï¼šå®žé™…ä¸´åºŠåœºæ™¯å¯ç”¨æ€§
- **ä¸€è‡´æ€§æ£€æŸ¥**ï¼šä¸ŽåŽŸå§‹å›¾åƒè¯Šæ–­ç»“è®ºä¸€è‡´æ€§

[ðŸ“– **å®Œæ•´ä»£ç ç¤ºä¾‹**: `data_augmentation/`](https://github.com/datawhalechina/med-imaging-primer/tree/main/src/ch05/) - åŒ…å«å®Œæ•´çš„åŒ»å­¦å›¾åƒå¢žå¼ºå®žçŽ°ã€2D/3Då˜æ¢å’Œæ¨¡æ€é€‚é…åŠŸèƒ½]

**å®žé™…åº”ç”¨æ•ˆæžœï¼š**
åŒ»å­¦å›¾åƒå¢žå¼ºåœ¨ä¸´åºŠåº”ç”¨ä¸­å·²è¯æ˜Žèƒ½å¤Ÿå°†æ¨¡åž‹æ€§èƒ½æå‡15-30%ï¼Œç‰¹åˆ«æ˜¯åœ¨æ•°æ®ç¨€ç¼ºçš„æƒ…å†µä¸‹ï¼Œåˆç†çš„å¢žå¼ºç­–ç•¥ç›¸å½“äºŽå°†è®­ç»ƒæ•°æ®æ‰©å¤§2-5å€ã€‚ä½†éœ€è¦å¼ºè°ƒçš„æ˜¯ï¼Œ**å¢žå¼ºç­–ç•¥å¿…é¡»ç»è¿‡ä¸´åºŠåŒ»ç”ŸéªŒè¯**ï¼Œç¡®ä¿ä¸å¼•å…¥åŒ»å­¦ä¸Šä¸åˆç†çš„å˜åŒ–ã€‚

### ðŸ¥ é€šç”¨åŒ»å­¦å›¾åƒå¢žå¼ºå®žçŽ°

æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå®Œæ•´çš„é€šç”¨åŒ»å­¦å›¾åƒå¢žå¼ºç³»ç»Ÿï¼Œæ”¯æŒå¤šç§æ¨¡æ€å’Œå¢žå¼ºç­–ç•¥ï¼š

![é€šç”¨åŒ»å­¦å›¾åƒå¢žå¼ºæ•ˆæžœæ¼”ç¤º](/images/ch05/medical_augmentation_ct_demo.png)
*å›¾ï¼šé€šç”¨åŒ»å­¦å›¾åƒå¢žå¼ºæŠ€æœ¯æ¼”ç¤ºã€‚å±•ç¤ºäº†CTå›¾åƒçš„åŸºç¡€å¢žå¼ºï¼ˆæ—‹è½¬ã€å¹³ç§»ã€ç¼©æ”¾ã€ç¿»è½¬ï¼‰ã€å¼ºåº¦å¢žå¼ºï¼ˆå¯¹æ¯”åº¦ã€äº®åº¦ã€å™ªå£°ï¼‰å’Œé«˜çº§å¢žå¼ºï¼ˆå¼¹æ€§å˜å½¢ã€å±€éƒ¨é®æŒ¡ï¼‰æ•ˆæžœï¼Œæ‰€æœ‰å¢žå¼ºéƒ½è€ƒè™‘äº†åŒ»å­¦çº¦æŸæ¡ä»¶ã€‚*

**æ ¸å¿ƒç‰¹æ€§ï¼š**
- **å¤šæ¨¡æ€æ”¯æŒ**ï¼šCTã€MRIã€Xå…‰ç­‰ä¸åŒæ¨¡æ€çš„ä¸“é—¨å‚æ•°
- **åŒ»å­¦çº¦æŸ**ï¼šä¿æŒè§£å‰–å­¦åˆç†æ€§å’Œä¸´åºŠè¯Šæ–­ä»·å€¼
- **åˆ†å±‚å¢žå¼º**ï¼šåŸºç¡€ã€å¼ºåº¦ã€é«˜çº§ä¸‰ä¸ªå±‚æ¬¡çš„å¢žå¼ºç­–ç•¥
- **å¯è°ƒå‚æ•°**ï¼šæ‰€æœ‰å¢žå¼ºå‚æ•°éƒ½å¯ä»¥æ ¹æ®å…·ä½“éœ€æ±‚è°ƒæ•´

**å®žé™…å¢žå¼ºæ•ˆæžœåˆ†æžï¼š**

| å¢žå¼ºç±»åž‹ | å‚æ•°è®¾ç½® | åŒ»å­¦æ„ä¹‰ | é€‚ç”¨åœºæ™¯ |
|---------|----------|----------|----------|
| **å¼¹æ€§å˜å½¢** | Î±=800, Ïƒ=6 | æ¨¡æ‹Ÿå‘¼å¸è¿åŠ¨ã€å¿ƒè„æåŠ¨ | èƒ¸éƒ¨ã€è…¹éƒ¨åŠ¨æ€å™¨å®˜ |
| **å¼ºåº¦å˜æ¢** | å¯¹æ¯”åº¦Ã—1.2, äº®åº¦+30 HU | é€‚åº”ä¸åŒæ‰«æè®¾å¤‡ | å¤šä¸­å¿ƒæ•°æ®ç»Ÿä¸€ |
| **å™ªå£°æ·»åŠ ** | é«˜æ–¯å™ªå£° Ïƒ=10-20 HU | æ¨¡æ‹Ÿç”µå­å™ªå£° | ç§»åŠ¨è®¾å¤‡ã€æ€¥è¯Šåœºæ™¯ |
| **å±€éƒ¨é®æŒ¡** | éšæœºçŸ©å½¢é®æŒ¡ | æ¨¡æ‹Ÿé‡‘å±žä¼ªå½±ã€æŽ¢å¤´é®æŒ¡ | å£è…”ã€éª¨ç§‘å½±åƒ |

[ðŸ“– **å®Œæ•´ä»£ç å®žçŽ°**: `medical_image_augmentation/simple_augmentation.py`](https://github.com/datawhalechina/med-imaging-primer/tree/main/src/ch05/medical_image_augmentation/) - åŒ…å«å®Œæ•´çš„é€šç”¨åŒ»å­¦å›¾åƒå¢žå¼ºä»£ç ï¼Œå¯ç›´æŽ¥è¿è¡Œç”Ÿæˆä¸Šè¿°å¯è§†åŒ–ç»“æžœ]

**å…³é”®ä»£ç ç»“æž„ï¼š**
```python
class SimpleMedicalAugmentation:
    """ç®€åŒ–çš„åŒ»å­¦å›¾åƒå¢žå¼ºç±»"""

    def __init__(self):
        self.output_dir = Path("output")
        self.output_dir.mkdir(exist_ok=True)

    def basic_augmentation(self, image, modality):
        """åŸºç¡€å¢žå¼º - å‡ ä½•å˜æ¢"""
        results = {}

        # æ—‹è½¬ - æ ¹æ®æ¨¡æ€è®¾ç½®ä¸åŒè§’åº¦
        if modality == 'CT':
            angles = [-5, 5]  # CTï¼šå°è§’åº¦æ—‹è½¬
        elif modality == 'MRI':
            angles = [-3, 3]  # MRIï¼šæ›´å°çš„è§’åº¦
        else:  # X-ray
            angles = [-2, 2]  # Xå…‰ï¼šæœ€å°è§’åº¦

        for angle in angles:
            rotated = rotate(image, angle, preserve_range=True)
            results[f'rotation_{angle}'] = rotated

        return results

    def intensity_augmentation(self, image, modality):
        """å¼ºåº¦å¢žå¼º - äº®åº¦ã€å¯¹æ¯”åº¦ã€å™ªå£°"""
        results = {}

        # å¯¹æ¯”åº¦è°ƒæ•´ - ä¿æŒåŒ»å­¦æ„ä¹‰
        if modality == 'CT':
            factors = [0.8, 1.2]  # CTHUå€¼èŒƒå›´
        elif modality == 'MRI':
            factors = [0.7, 1.0]  # MRIä¿¡å·å¼ºåº¦
        else:  # X-ray
            factors = [0.9, 1.1]  # Xå…‰ç°åº¦å€¼

        for factor in factors:
            adjusted = (image - np.mean(image)) * factor + np.mean(image)
            results[f'contrast_{factor}'] = adjusted

        return results

    def advanced_augmentation(self, image):
        """é«˜çº§å¢žå¼º - å¼¹æ€§å˜å½¢ã€å±€éƒ¨é®æŒ¡"""
        results = {}

        # å¼¹æ€§å˜å½¢ - æ¨¡æ‹Ÿç”Ÿç†è¿åŠ¨
        shape = image.shape
        alpha = 800  # å˜å½¢å¼ºåº¦
        sigma = 6    # å¹³æ»‘ç¨‹åº¦

        dx = gaussian(np.random.randn(*shape), sigma, mode='reflect') * alpha
        dy = gaussian(np.random.randn(*shape), sigma, mode='reflect') * alpha

        y, x = np.meshgrid(np.arange(shape[1]), np.arange(shape[0], dtype=np.float32))
        indices = np.array([y + dy, x + dx])

        warped = ndimage.map_coordinates(image, indices, order=1, mode='reflect')
        results['elastic_deformation'] = warped.reshape(shape)

        return results
```

### ðŸ”§ è¿è¡Œæ–¹æ³•å’Œç»“æžœ

æ‰§è¡Œä»¥ä¸‹ä»£ç è¿è¡Œå®Œæ•´çš„å¢žå¼ºæ¼”ç¤ºï¼š

```bash
cd src/ch05/medical_image_augmentation
python simple_augmentation.py
```

**è¾“å‡ºç»“æžœï¼š**
```
é€šç”¨åŒ»å­¦å›¾åƒå¢žå¼ºæ¼”ç¤º
============================================================
åˆ›å»ºç¤ºä¾‹åŒ»å­¦å›¾åƒ...
é€‰æ‹©CTå›¾åƒè¿›è¡Œæ¼”ç¤º
å›¾åƒå°ºå¯¸: (256, 256)
åƒç´ å€¼èŒƒå›´: [-1000.0, 1000.0]

åº”ç”¨åŸºç¡€å¢žå¼ºæŠ€æœ¯...
åº”ç”¨å¼ºåº¦å¢žå¼ºæŠ€æœ¯...
åº”ç”¨é«˜çº§å¢žå¼ºæŠ€æœ¯...

ç”Ÿæˆå¢žå¼ºæ•ˆæžœå¯è§†åŒ–...

==================================================
å¢žå¼ºæŠ€æœ¯ç»Ÿè®¡ç»“æžœ:
==================================================
æ¨¡æ€ç±»åž‹: CT
åŸºç¡€å¢žå¼º: 7 ç§
å¼ºåº¦å¢žå¼º: 8 ç§
é«˜çº§å¢žå¼º: 3 ç§

CTå›¾åƒä¿¡æ¯:
  å°ºå¯¸: (256, 256)
  åƒç´ å€¼èŒƒå›´: [-1000.0, 1000.0]
  å¹³å‡å€¼: -325.0

åŒ»å­¦å¢žå¼ºçº¦æŸ:
  [OK] ä¿æŒè§£å‰–å­¦åˆç†æ€§
  [OK] ä¿æŠ¤ç—…ç†ç‰¹å¾
  [OK] ç»´æŒä¸´åºŠè¯Šæ–­ä»·å€¼
==================================================

å¯è§†åŒ–ç»“æžœå·²ä¿å­˜: output/medical_augmentation_ct_demo.png

æ¼”ç¤ºå®Œæˆ!
å¯è§†åŒ–æ–‡ä»¶: output/medical_augmentation_ct_demo.png
```

### é«˜çº§å¢žå¼ºæŠ€æœ¯

#### Mixupå’ŒCutMix

```python
import torch.nn.functional as F

class MedicalMixup:
    """
    åŒ»å­¦å›¾åƒMixupæŠ€æœ¯
    """
    def __init__(self, alpha=1.0, cutmix_prob=0.5):
        self.alpha = alpha
        self.cutmix_prob = cutmix_prob

    def mixup_data(self, x, y, alpha=1.0):
        """
        æ ‡å‡†Mixupå®žçŽ°
        """
        if alpha > 0:
            lam = np.random.beta(alpha, alpha)
        else:
            lam = 1

        batch_size = x.size(0)
        index = torch.randperm(batch_size).to(x.device)

        mixed_x = lam * x + (1 - lam) * x[index, :]
        y_a, y_b = y, y[index]

        return mixed_x, y_a, y_b, lam
```

---

## ðŸ¤– æ·±åº¦å­¦ä¹ é©±åŠ¨çš„å¢žå¼ºç­–ç•¥

### å­¦ä¹ å¢žå¼ºç­–ç•¥

#### è‡ªåŠ¨å¢žå¼º

```python
import torch.optim as optim

class AutoAugmentation:
    """
    è‡ªåŠ¨å¢žå¼ºç­–ç•¥å­¦ä¹ 
    """
    def __init__(self, num_policies=5, num_operations=10):
        self.num_policies = num_policies
        self.num_operations = num_operations
        self.policies = self._initialize_policies()

    def _initialize_policies(self):
        """
        åˆå§‹åŒ–å¢žå¼ºç­–ç•¥
        """
        # åŒ»å­¦å›¾åƒç‰¹å®šçš„æ“ä½œ
        operations = [
            'rotate', 'translate_x', 'translate_y', 'shear_x', 'shear_y',
            'contrast', 'brightness', 'gamma', 'noise', 'blur'
        ]

        policies = []
        for _ in range(self.num_policies):
            policy = []
            for _ in range(2):  # æ¯ä¸ªç­–ç•¥åŒ…å«2ä¸ªå­æ“ä½œ
                op = np.random.choice(operations)
                prob = np.random.uniform(0.1, 0.9)
                magnitude = np.random.uniform(0.1, 1.0)
                policy.append((op, prob, magnitude))
            policies.append(policy)

        return policies
```

#### ç”Ÿæˆå¯¹æŠ—ç½‘ç»œ(GAN)å¢žå¼º

```python
import torch.nn as nn

class MedicalGAN:
    """
    åŒ»å­¦å›¾åƒç”Ÿæˆå¯¹æŠ—ç½‘ç»œ
    """
    def __init__(self, latent_dim=100, image_size=(256, 256)):
        self.latent_dim = latent_dim
        self.image_size = image_size
        self.generator = self._build_generator()
        self.discriminator = self._build_discriminator()

    def _build_generator(self):
        """
        æž„å»ºç”Ÿæˆå™¨
        """
        class Generator(nn.Module):
            def __init__(self, latent_dim, channels=1):
                super().__init__()

                self.main = nn.Sequential(
                    # è¾“å…¥: latent_dim -> 4x4x512
                    nn.ConvTranspose2d(latent_dim, 512, 4, 1, 0, bias=False),
                    nn.BatchNorm2d(512),
                    nn.ReLU(True),

                    # 128x128x16 -> 256x256x1
                    nn.ConvTranspose2d(16, channels, 4, 2, 1, bias=False),
                    nn.Tanh()
                )

            def forward(self, x):
                return self.main(x)

        return Generator(self.latent_dim)
```

---

## ðŸ”„ å›¾åƒæ¢å¤ä¸Žé‡å»ºæŠ€æœ¯

### ðŸ” åŒ»å­¦å›¾åƒé€€åŒ–çš„æ ¹æœ¬åŽŸå› 

**ç†è§£åŒ»å­¦å›¾åƒè´¨é‡é€€åŒ–æ˜¯æœ‰æ•ˆæ¢å¤çš„å‰æ**ï¼š

#### ðŸŽ¯ å¸¸è§é€€åŒ–ç±»åž‹åŠæœºåˆ¶

**1. ç‰©ç†å› ç´ å¯¼è‡´çš„é€€åŒ–ï¼š**
- **é‡å­å™ªå£°**ï¼šXå°„çº¿ã€CTä¸­çš„å…‰å­ç»Ÿè®¡å™ªå£°
- **ç”µå­å™ªå£°**ï¼šæŽ¢æµ‹å™¨ã€æ”¾å¤§ç”µè·¯ä¸­çš„çƒ­å™ªå£°
- **æ•£å°„æ•ˆåº”**ï¼šXå…‰ã€è¶…å£°ä¸­çš„æ•£å°„å¹²æ‰°
- **è¿åŠ¨ä¼ªå½±**ï¼šæ‚£è€…è¿åŠ¨ã€å™¨å®˜æåŠ¨é€ æˆçš„æ¨¡ç³Š

**2. æŠ€æœ¯é™åˆ¶å¯¼è‡´çš„é€€åŒ–ï¼š**
- **åˆ†è¾¨çŽ‡é™åˆ¶**ï¼šæŽ¢æµ‹å™¨ç‰©ç†åˆ†è¾¨çŽ‡ä¸è¶³
- **åŠ¨æ€èŒƒå›´é™åˆ¶**ï¼šæ— æ³•åŒæ—¶æ˜¾ç¤ºé«˜ä½Žå¯†åº¦ç»„ç»‡
- **é‡‡æ ·ä¸è¶³**ï¼šNyquistå®šç†ä¸æ»¡è¶³å¯¼è‡´çš„æ··å 
- **é‡åŒ–è¯¯å·®**ï¼šæ¨¡æ•°è½¬æ¢è¿‡ç¨‹ä¸­çš„ç²¾åº¦æŸå¤±

**3. æ‚£è€…ç›¸å…³å› ç´ ï¼š**
- **ä½“åž‹å·®å¼‚**ï¼šè‚¥èƒ–æ‚£è€…çš„å›¾åƒè´¨é‡ä¸‹é™
- **é‡‘å±žæ¤å…¥ç‰©**ï¼šä¹‰é½¿ã€èµ·æå™¨ç­‰é€ æˆçš„ä¼ªå½±
- **ç”Ÿç†è¿åŠ¨**ï¼šå‘¼å¸ã€å¿ƒè·³ã€è‚ è •åŠ¨ç­‰
- **é…åˆç¨‹åº¦**ï¼šæ‚£è€…æ— æ³•ä¿æŒé™æ­¢æˆ–é…åˆå‘¼å¸

#### ðŸ“Š é€€åŒ–ç¨‹åº¦çš„å®šé‡è¯„ä¼°

| é€€åŒ–ç±»åž‹ | è¯„ä¼°æŒ‡æ ‡ | è½»åº¦å½±å“ | ä¸­åº¦å½±å“ | é‡åº¦å½±å“ |
|---------|---------|----------|----------|----------|
| **å™ªå£°** | SNR(dB) | >30 | 20-30 | <20 |
| **åˆ†è¾¨çŽ‡** | MTF(%) | >80 | 50-80 | <50 |
| **ä¼ªå½±** | ä¼ªå½±æŒ‡æ•° | <5% | 5-15% | >15% |
| **å¯¹æ¯”åº¦** | CNR | >10 | 5-10 | <5 |

### åŽ»å™ªå’Œä¼ªå½±åŽ»é™¤

#### ðŸ› ï¸ åŽ»å™ªæ–¹æ³•çš„åŒ»å­¦é€‚ç”¨æ€§

åŒ»å­¦å›¾åƒåŽ»å™ªéœ€è¦åœ¨ä¿æŒç»†èŠ‚çš„åŒæ—¶åŽ»é™¤å™ªå£°ï¼Œè¿™éœ€è¦æƒè¡¡è¯Šæ–­ä¿¡æ¯å®Œæ•´æ€§ï¼š

**ä¼ ç»ŸåŽ»å™ªæ–¹æ³•çš„ä¼˜ç¼ºç‚¹ï¼š**
- **é«˜æ–¯æ»¤æ³¢**ï¼šç®€å•å¿«é€Ÿï¼Œä½†ä¼šæ¨¡ç³Šè¾¹ç•Œ
- **ä¸­å€¼æ»¤æ³¢**ï¼šä¿ç•™è¾¹ç¼˜ï¼Œä½†å¯èƒ½ä¸¢å¤±ç»†èŠ‚çº¹ç†
- **åŒè¾¹æ»¤æ³¢**ï¼šä¿è¾¹åŽ»å™ªï¼Œä½†å‚æ•°è°ƒèŠ‚å›°éš¾
- **éžå±€éƒ¨å‡å€¼**ï¼šæ•ˆæžœä¼˜ç§€ï¼Œä½†è®¡ç®—å¼€é”€å¤§

**æ·±åº¦å­¦ä¹ æ–¹æ³•çš„ä¼˜åŠ¿ï¼š**
- **ç«¯åˆ°ç«¯å­¦ä¹ **ï¼šç›´æŽ¥å­¦ä¹ é€€åŒ–åˆ°å¹²å‡€çš„æ˜ å°„
- **åŒ»å­¦ç‰¹å¼‚æ€§**ï¼šå¯ä»¥å­¦ä¹ åŒ»å­¦å›¾åƒç‰¹æœ‰çš„ç‰¹å¾
- **å¤šå°ºåº¦å¤„ç†**ï¼šåŒæ—¶å¤„ç†ä¸åŒå°ºåº¦çš„å™ªå£°

```python
class MedicalImageDenoising:
    """
    åŒ»å­¦å›¾åƒåŽ»å™ªæŠ€æœ¯
    """
    def __init__(self):
        pass

    def traditional_denoising(self, image, method='gaussian'):
        """
        ä¼ ç»ŸåŽ»å™ªæ–¹æ³•
        """
        if method == 'gaussian':
            return cv2.GaussianBlur(image, (5, 5), 0)

        elif method == 'median':
            return cv2.medianBlur(image, 5)

        elif method == 'bilateral':
            return cv2.bilateralFilter(image, 9, 75, 75)

        elif method == 'non_local_means':
            return cv2.fastNlMeansDenoising(image, None, 10, 7, 21)

        else:
            raise ValueError(f"Unknown denoising method: {method}")

    def wavelet_denoising(self, image, wavelet='db4', sigma=0.1):
        """
        å°æ³¢åŽ»å™ª
        """
        import pywt

        # å¤šçº§å°æ³¢åˆ†è§£
        coeffs = pywt.wavedec2(image, wavelet, level=3)

        # ä¼°è®¡å™ªå£°æ°´å¹³
        # ä½¿ç”¨æœ€é«˜é¢‘å°æ³¢ç³»æ•°ä¼°è®¡å™ªå£°
        sigma_est = np.median(np.abs(coeffs[-1])) / 0.6745

        # é˜ˆå€¼å¤„ç†
        threshold = sigma_est * np.sqrt(2 * np.log(image.size))

        # è½¯é˜ˆå€¼
        coeffs_thresh = list(coeffs)
        coeffs_thresh[1:] = [pywt.threshold(detail, threshold, mode='soft')
                           for detail in coeffs_thresh[1:]]

        # é‡å»º
        denoised = pywt.waverec2(coeffs_thresh, wavelet)

        return denoised
```

### è¶…åˆ†è¾¨çŽ‡é‡å»º

#### å•å¹…å›¾åƒè¶…åˆ†è¾¨çŽ‡

```python
class MedicalSuperResolution:
    """
    åŒ»å­¦å›¾åƒè¶…åˆ†è¾¨çŽ‡
    """
    def __init__(self):
        pass

    def traditional_interpolation(self, image, scale_factor=2, method='bicubic'):
        """
        ä¼ ç»Ÿæ’å€¼æ–¹æ³•
        """
        if method == 'bicubic':
            h, w = image.shape
            new_h, new_w = int(h * scale_factor), int(w * scale_factor)
            return cv2.resize(image, (new_w, new_h), interpolation=cv2.INTER_CUBIC)

        elif method == 'bilinear':
            h, w = image.shape
            new_h, new_w = int(h * scale_factor), int(w * scale_factor)
            return cv2.resize(image, (new_w, new_h), interpolation=cv2.INTER_LINEAR)

        else:
            raise ValueError(f"Unknown interpolation method: {method}")

class SRCNN(nn.Module):
    """
    è¶…åˆ†è¾¨çŽ‡å·ç§¯ç¥žç»ç½‘ç»œ
    """
    def __init__(self, num_channels=1):
        super().__init__()

        # ç‰¹å¾æå–
        self.conv1 = nn.Conv2d(num_channels, 64, kernel_size=9, padding=4)
        self.relu1 = nn.ReLU(inplace=True)

        # éžçº¿æ€§æ˜ å°„
        self.conv2 = nn.Conv2d(64, 32, kernel_size=1, padding=0)
        self.relu2 = nn.ReLU(inplace=True)

        # é‡å»º
        self.conv3 = nn.Conv2d(32, num_channels, kernel_size=5, padding=2)

    def forward(self, x):
        x = self.relu1(self.conv1(x))
        x = self.relu2(self.conv2(x))
        x = self.conv3(x)
        return x
```

---

## ðŸ“ å¢žå¼ºæ•ˆæžœè¯„ä¼°æŒ‡æ ‡

### å®šé‡è¯„ä¼°æŒ‡æ ‡

#### å›¾åƒè´¨é‡è¯„ä¼°

```python
class ImageQualityAssessment:
    """
    å›¾åƒè´¨é‡è¯„ä¼°
    """
    def __init__(self):
        pass

    def calculate_psnr(self, img1, img2, max_val=255.0):
        """
        è®¡ç®—å³°å€¼ä¿¡å™ªæ¯”
        """
        mse = np.mean((img1 - img2) ** 2)
        if mse == 0:
            return float('inf')
        return 20 * np.log10(max_val / np.sqrt(mse))

    def calculate_ssim(self, img1, img2):
        """
        è®¡ç®—ç»“æž„ç›¸ä¼¼æ€§æŒ‡æ•°
        """
        from skimage.metrics import structural_similarity as ssim
        return ssim(img1, img2, data_range=255)

    def calculate_mae(self, img1, img2):
        """
        è®¡ç®—å¹³å‡ç»å¯¹è¯¯å·®
        """
        return np.mean(np.abs(img1 - img2))
```

#### ä»»åŠ¡å¯¼å‘è¯„ä¼°

```python
class TaskOrientedEvaluation:
    """
    ä»»åŠ¡å¯¼å‘çš„å¢žå¼ºæ•ˆæžœè¯„ä¼°
    """
    def __init__(self, segmentation_model=None, classification_model=None):
        self.segmentation_model = segmentation_model
        self.classification_model = classification_model

    def evaluate_segmentation_performance(self, original_images, enhanced_images, ground_truth_masks):
        """
        è¯„ä¼°åˆ†å‰²ä»»åŠ¡æ€§èƒ½
        """
        if self.segmentation_model is None:
            raise ValueError("Segmentation model not provided")

        results = {
            'original': [],
            'enhanced': []
        }

        for orig_img, enh_img, gt_mask in zip(original_images, enhanced_images, ground_truth_masks):
            # åŽŸå§‹å›¾åƒåˆ†å‰²
            orig_pred = self.segmentation_model.predict(orig_img)
            orig_metrics = self._calculate_segmentation_metrics(orig_pred, gt_mask)

            # å¢žå¼ºå›¾åƒåˆ†å‰²
            enh_pred = self.segmentation_model.predict(enh_img)
            enh_metrics = self._calculate_segmentation_metrics(enh_pred, gt_mask)

            results['original'].append(orig_metrics)
            results['enhanced'].append(enh_metrics)

        # è®¡ç®—å¹³å‡æ€§èƒ½æå‡
        avg_orig = self._average_metrics(results['original'])
        avg_enh = self._average_metrics(results['enhanced'])

        improvement = {}
        for key in avg_orig.keys():
            improvement[key] = (avg_enh[key] - avg_orig[key]) / avg_orig[key] * 100

        return {
            'original_performance': avg_orig,
            'enhanced_performance': avg_enh,
            'improvement_percentage': improvement
        }
```

---

## ðŸ¥ ä¸´åºŠåº”ç”¨æ¡ˆä¾‹åˆ†æž

### æ•°æ®å¢žå¼ºæ•ˆæžœå¯¹æ¯”

#### ä¸åŒå¢žå¼ºç­–ç•¥çš„æ€§èƒ½æ¯”è¾ƒ

```python
def compare_augmentation_strategies(model, train_data, val_data, strategies, num_epochs=10):
    """
    æ¯”è¾ƒä¸åŒå¢žå¼ºç­–ç•¥çš„æ•ˆæžœ
    """
    results = {}

    for strategy_name, augmentation in strategies.items():
        print(f"\nè®­ç»ƒç­–ç•¥: {strategy_name}")

        # åˆ›å»ºå¢žå¼ºåŽçš„æ•°æ®åŠ è½½å™¨
        augmented_train_loader = create_augmented_loader(train_data, augmentation)

        # è®­ç»ƒæ¨¡åž‹
        model_copy = copy.deepcopy(model)
        optimizer = optim.Adam(model_copy.parameters(), lr=0.001)

        training_history = []

        for epoch in range(num_epochs):
            model_copy.train()
            train_loss = 0.0

            for batch_idx, (data, targets) in enumerate(augmented_train_loader):
                optimizer.zero_grad()
                output = model_copy(data)
                loss = F.cross_entropy(output, targets)
                loss.backward()
                optimizer.step()

                train_loss += loss.item()

            # éªŒè¯
            val_accuracy = evaluate_model(model_copy, val_data)

            training_history.append({
                'epoch': epoch + 1,
                'train_loss': train_loss / len(augmented_train_loader),
                'val_accuracy': val_accuracy
            })

            print(f'Epoch {epoch+1}, Loss: {train_loss/len(augmented_train_loader):.4f}, '
                  f'Val Acc: {val_accuracy:.4f}')

        results[strategy_name] = training_history

    return results
```

### å›¾åƒæ¢å¤æ¡ˆä¾‹åˆ†æž

#### è¶…åˆ†è¾¨çŽ‡åœ¨åŒ»å­¦å½±åƒä¸­çš„åº”ç”¨

```python
def super_resolution_case_study(lr_images, hr_images, model):
    """
    è¶…åˆ†è¾¨çŽ‡æ¡ˆä¾‹ç ”ç©¶
    """
    print("åŒ»å­¦å½±åƒè¶…åˆ†è¾¨çŽ‡æ¡ˆä¾‹ç ”ç©¶")
    print("=" * 50)

    # è¯„ä¼°åŽŸå§‹ä½Žåˆ†è¾¨çŽ‡å›¾åƒè´¨é‡
    print("\n1. ä½Žåˆ†è¾¨çŽ‡å›¾åƒè´¨é‡è¯„ä¼°:")
    for i, (lr, hr) in enumerate(zip(lr_images[:3], hr_images[:3])):
        psnr = calculate_psnr(lr, hr)
        ssim = calculate_ssim(lr, hr)
        print(f"å›¾åƒ {i+1}: PSNR = {psnr:.2f}dB, SSIM = {ssim:.4f}")

    # è¶…åˆ†è¾¨çŽ‡é‡å»º
    print("\n2. è¶…åˆ†è¾¨çŽ‡é‡å»º...")
    sr_images = []
    for lr in lr_images:
        sr = model(lr.unsqueeze(0).unsqueeze(0).float())
        sr_images.append(sr.squeeze().numpy())

    # è¯„ä¼°è¶…åˆ†è¾¨çŽ‡ç»“æžœ
    print("\n3. è¶…åˆ†è¾¨çŽ‡ç»“æžœè´¨é‡è¯„ä¼°:")
    improvements = {'psnr': [], 'ssim': []}

    for i, (lr, sr, hr) in enumerate(zip(lr_images[:3], sr_images[:3], hr_images[:3])):
        # è¶…åˆ†è¾¨çŽ‡åŽè´¨é‡
        sr_psnr = calculate_psnr(sr, hr)
        sr_ssim = calculate_ssim(sr, hr)

        # æ”¹è¿›é‡
        lr_psnr = calculate_psnr(lr, hr)
        lr_ssim = calculate_ssim(lr, hr)

        psnr_improvement = sr_psnr - lr_psnr
        ssim_improvement = sr_ssim - lr_ssim

        improvements['psnr'].append(psnr_improvement)
        improvements['ssim'].append(ssim_improvement)

        print(f"å›¾åƒ {i+1}:")
        print(f"  ä½Žåˆ†è¾¨çŽ‡: PSNR = {lr_psnr:.2f}dB, SSIM = {lr_ssim:.4f}")
        print(f"  è¶…åˆ†è¾¨çŽ‡: PSNR = {sr_psnr:.2f}dB, SSIM = {sr_ssim:.4f}")
        print(f"  æ”¹è¿›: PSNR +{psnr_improvement:.2f}dB, SSIM +{ssim_improvement:.4f}")

    # å¹³å‡æ”¹è¿›
    avg_psnr_improvement = np.mean(improvements['psnr'])
    avg_ssim_improvement = np.mean(improvements['ssim'])

    print(f"\n4. å¹³å‡æ”¹è¿›:")
    print(f"PSNRæ”¹è¿›: +{avg_psnr_improvement:.2f}dB")
    print(f"SSIMæ”¹è¿›: +{avg_ssim_improvement:.4f}")

    return {
        'average_psnr_improvement': avg_psnr_improvement,
        'average_ssim_improvement': avg_ssim_improvement,
        'sr_images': sr_images
    }
```

---

## ðŸŽ¯ æ ¸å¿ƒè¦ç‚¹ä¸Žå‘å±•æ–¹å‘

### 1. æ•°æ®å¢žå¼ºæŠ€æœ¯
- **åŸºç¡€å¢žå¼º**: å‡ ä½•å˜æ¢ã€å¼ºåº¦è°ƒæ•´ï¼Œä¿æŒè§£å‰–ç»“æž„
- **é«˜çº§å¢žå¼º**: Mixupã€CutMixã€å¯¹æŠ—å¢žå¼º
- **æ™ºèƒ½å¢žå¼º**: AutoAugmentationã€GANç”Ÿæˆ

### 2. å›¾åƒæ¢å¤æ–¹æ³•
- **ä¼ ç»Ÿæ–¹æ³•**: æ»¤æ³¢åŽ»å™ªã€æ’å€¼å¢žå¼º
- **æ·±åº¦å­¦ä¹ **: DnCNNã€SRCNNã€EDSR
- **ä»»åŠ¡å¯¼å‘**: åŸºäºŽä¸‹æ¸¸ä»»åŠ¡æ€§èƒ½ä¼˜åŒ–

### 3. è¯„ä¼°æŒ‡æ ‡
- **å®¢è§‚æŒ‡æ ‡**: PSNRã€SSIMã€MAE
- **ä¸»è§‚è¯„ä¼°**: åŒ»ç”Ÿé˜…ç‰‡ä½“éªŒ
- **ä»»åŠ¡æŒ‡æ ‡**: åˆ†å‰²/åˆ†ç±»å‡†ç¡®çŽ‡æå‡

### 4. ä¸´åºŠåº”ç”¨æŒ‡å¯¼
- **æ¨¡æ€ç‰¹å¼‚æ€§**: é’ˆå¯¹ä¸åŒæˆåƒè®¾å¤‡çš„å¢žå¼ºç­–ç•¥
- **æ•°æ®åˆè§„**: ä¿æŠ¤æ‚£è€…éšç§çš„å¢žå¼ºæ–¹æ³•
- **å¯è§£é‡Šæ€§**: å¢žå¼ºè¿‡ç¨‹çš„å¯è§£é‡Šæ€§

### 5. æœªæ¥å‘å±•æ–¹å‘
- **è‡ªé€‚åº”å¢žå¼º**: æ ¹æ®å›¾åƒå†…å®¹è‡ªåŠ¨é€‰æ‹©æœ€ä½³ç­–ç•¥
- **è·¨æ¨¡æ€å¢žå¼º**: åˆ©ç”¨å¤šæ¨¡æ€ä¿¡æ¯æå‡å›¾åƒè´¨é‡
- **è”é‚¦å­¦ä¹ å¢žå¼º**: åˆ†å¸ƒå¼æ•°æ®å¢žå¼ºä¸Žéšç§ä¿æŠ¤

---

::: info ðŸŽ¯ ç« èŠ‚å®Œæˆ
é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œä½ å·²ç»æŽŒæ¡äº†åŒ»å­¦å›¾åƒå¢žå¼ºä¸Žæ¢å¤çš„æ ¸å¿ƒæŠ€æœ¯ã€‚ä»Žä¼ ç»Ÿçš„å‡ ä½•å˜æ¢åˆ°å…ˆè¿›çš„ç”Ÿæˆå¯¹æŠ—ç½‘ç»œï¼Œä»Žç®€å•çš„æ»¤æ³¢åŽ»å™ªåˆ°å¤æ‚çš„æ·±åº¦å­¦ä¹ è¶…åˆ†è¾¨çŽ‡ï¼Œè¿™äº›æŠ€æœ¯å°†å¸®åŠ©ä½ è§£å†³åŒ»å­¦å½±åƒæ•°æ®ç¨€ç¼ºå’Œè´¨é‡é—®é¢˜ï¼Œä¸ºåŽç»­çš„æ·±åº¦å­¦ä¹ æ¨¡åž‹æä¾›æ›´å¥½çš„æ•°æ®åŸºç¡€ã€‚
:::